import type { Incident } from './types'

export interface KnowledgeArticle {
  id: string
  title: string
  content: string
  summary: string
  tags: string[]
  category: 'incident' | 'solution' | 'procedure' | 'troubleshooting' | 'best-practice'
  severity?: 'critical' | 'high' | 'medium' | 'low'
  relatedIncidentIds: string[]
  views: number
  helpful: number
  notHelpful: number
  createdAt: number
  updatedAt: number
  createdBy: string
  autoGenerated: boolean
}

export interface KnowledgeBaseStats {
  totalArticles: number
  autoGeneratedArticles: number
  manualArticles: number
  totalViews: number
  averageHelpfulness: number
  articlesByCategory: Record<string, number>
}

export async function generateKnowledgeArticle(incident: Incident): Promise<KnowledgeArticle> {
  if (!incident.resolution || incident.status !== 'resolved') {
    throw new Error('Cannot generate article from unresolved incident')
  }

  const tags = [
    incident.severity,
    ...incident.assignedAgents,
    ...(incident.templateId ? ['template-based'] : [])
  ]

  const prompt = `Generate a knowledge base article from this resolved incident:

Title: ${incident.title}
Description: ${incident.description}
Severity: ${incident.severity}
Proposed Solution: ${incident.proposedSolution || 'N/A'}
Resolution: ${incident.resolution}

Create a knowledge article with:
1. A clear, descriptive title
2. A brief summary (2-3 sentences)
3. Detailed content including:
   - Problem description
   - Root cause analysis (if available)
   - Solution steps
   - Prevention recommendations

Return as JSON with fields: title, summary, content`

  const response = await window.spark.llm(prompt, 'gpt-4o', true)
  const articleData = JSON.parse(response)

  return {
    id: `kb-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
    title: articleData.title || incident.title,
    content: articleData.content,
    summary: articleData.summary,
    tags,
    category: 'solution',
    severity: incident.severity,
    relatedIncidentIds: [incident.id],
    views: 0,
    helpful: 0,
    notHelpful: 0,
    createdAt: Date.now(),
    updatedAt: Date.now(),
    createdBy: incident.approvedBy || 'system',
    autoGenerated: true
  }
}

export function searchKnowledgeBase(
  articles: KnowledgeArticle[],
  query: string,
  filters?: {
    category?: string
    severity?: string
    tags?: string[]
  }
): KnowledgeArticle[] {
  let filtered = articles

  if (filters?.category) {
    filtered = filtered.filter(a => a.category === filters.category)
  }

  if (filters?.severity) {
    filtered = filtered.filter(a => a.severity === filters.severity)
  }

  if (filters?.tags && filters.tags.length > 0) {
    filtered = filtered.filter(a => 
      filters.tags!.some(tag => a.tags.includes(tag))
    )
  }

  if (query.trim()) {
    const lowerQuery = query.toLowerCase()
    filtered = filtered.filter(a =>
      a.title.toLowerCase().includes(lowerQuery) ||
      a.summary.toLowerCase().includes(lowerQuery) ||
      a.content.toLowerCase().includes(lowerQuery) ||
      a.tags.some(tag => tag.toLowerCase().includes(lowerQuery))
    )
  }

  return filtered.sort((a, b) => {
    const aScore = (a.helpful / Math.max(1, a.helpful + a.notHelpful)) * 100
    const bScore = (b.helpful / Math.max(1, b.helpful + b.notHelpful)) * 100
    return bScore - aScore
  })
}

export async function findSimilarArticles(
  incident: Incident,
  articles: KnowledgeArticle[]
): Promise<Array<KnowledgeArticle & { relevanceScore: number }>> {
  if (articles.length === 0) return []

  const prompt = `Given this incident:
Title: ${incident.title}
Description: ${incident.description}
Severity: ${incident.severity}

And these knowledge articles:
${articles.map(a => `ID: ${a.id}\nTitle: ${a.title}\nSummary: ${a.summary}\n`).join('\n')}

Return a JSON object with a single property "matches" containing an array of article IDs with their relevance scores (0-100).
Format: { "matches": [{"id": "kb-123", "score": 85}, ...] }
Only include articles with score > 50.`

  try {
    const response = await window.spark.llm(prompt, 'gpt-4o-mini', true)
    const result = JSON.parse(response)
    
    return result.matches
      .map((match: { id: string; score: number }) => {
        const article = articles.find(a => a.id === match.id)
        return article ? { ...article, relevanceScore: match.score } : null
      })
      .filter((a: any) => a !== null)
      .sort((a: any, b: any) => b.relevanceScore - a.relevanceScore)
  } catch (error) {
    console.error('Error finding similar articles:', error)
    return []
  }
}

export function getKnowledgeBaseStats(articles: KnowledgeArticle[]): KnowledgeBaseStats {
  const articlesByCategory: Record<string, number> = {}
  
  articles.forEach(article => {
    articlesByCategory[article.category] = (articlesByCategory[article.category] || 0) + 1
  })

  const totalViews = articles.reduce((sum, a) => sum + a.views, 0)
  const articlesWithRatings = articles.filter(a => (a.helpful + a.notHelpful) > 0)
  const averageHelpfulness = articlesWithRatings.length > 0
    ? articlesWithRatings.reduce((sum, a) => {
        const score = (a.helpful / (a.helpful + a.notHelpful)) * 100
        return sum + score
      }, 0) / articlesWithRatings.length
    : 0

  return {
    totalArticles: articles.length,
    autoGeneratedArticles: articles.filter(a => a.autoGenerated).length,
    manualArticles: articles.filter(a => !a.autoGenerated).length,
    totalViews,
    averageHelpfulness,
    articlesByCategory
  }
}

export function incrementArticleView(articles: KnowledgeArticle[], articleId: string): KnowledgeArticle[] {
  return articles.map(a => 
    a.id === articleId 
      ? { ...a, views: a.views + 1 }
      : a
  )
}

export function rateArticle(
  articles: KnowledgeArticle[],
  articleId: string,
  helpful: boolean
): KnowledgeArticle[] {
  return articles.map(a => 
    a.id === articleId
      ? {
          ...a,
          helpful: helpful ? a.helpful + 1 : a.helpful,
          notHelpful: !helpful ? a.notHelpful + 1 : a.notHelpful
        }
      : a
  )
}
